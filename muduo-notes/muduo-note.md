# Muduo源码解析

## 线程同步精要

四项原则：
1. 尽可能低限度地共享对象
2. 尽量使用高级并发编程构建
3. 使用底层同步原语时只使用非递归地互斥锁和条件变量
4. 除了使用atomic整数外，不自己编写lock-free代码


同步原语：

- 加锁原语：互斥锁MutexLock, MutexLockGuard
- 等待原语：条件变量Condition

高级同步组件：

- BlockingQueue
- CoundDownLatch


生产代码中的线程等待场景：
- 等待资源可用：select, poll, epoll
- 等着进入临界区：mutex
- 等待已知的一段时间：注册timer
- 等待某个事件发生：条件变量或IO事件回调

注：不要将sleep作为同步原语使用！不要在用户态做polling。

归纳：
1. 线程同步的四项原则，尽量使用高层同步设施（线程池、队列、倒计时）；
2. 使用普通互斥器和条件变量完成剩余的同步任务，采用RAII和scoped locking。

  
### 问题

使用RAII的锁时，能保证不会出现死锁吗？

C++ mutex是non-recursive锁吗？

条件变量可以被除等待锁的其它因素唤醒吗？

notify和notifyAll的区别？

条件变量wait之前可以不获取锁吗？notify之前可以不获取锁吗？

P41 dequeue有问题，需要清空所有内容（压力可能会集中到单个消费线程中）；使用notifyAll，
还是可能会漏掉消费某一个元素；一种方案是消费者接力notify，出队列后判断是否需要更多的消费线程
来处理队列。

生产者-消费者的两个层次：

（1）线程安全的对象组件；

（2）生产者-消费者线程。

如何判断对象设计时是否支持拷贝构造和赋值？

构造函数和析构函数的调用时机和调用特点？为什么构造函数中不允许申请资源？

单个线程先后获取相同锁的行为：C++ mutex的行为：？；用户角度的行为：直接认为加锁成功？
non-recursive锁行为

MutexLockGuard(mutex)写法是错误的。




